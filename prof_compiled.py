# File automatically generated by RBNF.
from rbnf.std.common import (recover_codes)
from rbnf.bootstrap import loader as ruiko
ulang = ruiko.Language('ulang')


@ulang
class pattern(ruiko.Lexer):
    @staticmethod
    def regex():
        return ['[^/\\sa-z]+']


@ulang
class url(ruiko.Parser):
    @staticmethod
    def bnf():
        return ruiko.Bind(
            'result',
            ruiko.And([
                ruiko.Or([ruiko.C('https:'),
                          ruiko.C('http:')]),
                ruiko.C('//'),
                ruiko.Seq(ruiko.N('pattern'), 1, -1),
                ruiko.Seq(
                    ruiko.And([ruiko.C('/'), ruiko.N('pattern')]), 0, -1),
                ruiko.Seq(ruiko.C('/'), 0, 1)
            ]))

    @staticmethod
    def rewrite(state):
        (result, ) = map(state.ctx.get, ('result', ))
        return result


@ulang
class text(ruiko.Parser):
    @staticmethod
    def bnf():
        return ruiko.Seq(
            ruiko.Or([
                ruiko.Push('urls', ruiko.Named('url')),
                ruiko.AnyNot(ruiko.Named('url'))
            ]), 1, -1)

    @staticmethod
    def rewrite(state):
        (urls, ) = map(state.ctx.get, ('urls', ))
        return tuple((recover_codes(each) for each in urls))


@ulang
class pattern(ruiko.Lexer):
    @staticmethod
    def regex():
        return ['[a-zA-Z0-9_]+']


@ulang
class space(ruiko.Lexer):
    @staticmethod
    def regex():
        return ['\\s+']


ulang.ignore()
ulang.build()
ulang.as_fixed()
_impl = ulang.implementation
from rbnf.core.State import State
_ze_exp = text.match
lexer = ulang.lexer
ze_exp = lambda text: _ze_exp(tuple(lexer(text)), State(_impl))