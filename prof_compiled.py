# File automatically generated by RBNF.
from rbnf.std.common import (recover_codes, Tokenizer)
from rbnf.bootstrap import loader as ruiko
ulang = ruiko.Language('ulang')


@ulang
class pattern(ruiko.Lexer):
    @staticmethod
    def regex():
        return ['[^/\\sa-z]+']


@ulang
class url(ruiko.Parser):
    @staticmethod
    def bnf():
        return ruiko.And([
            ruiko.Bind('prefix',
                       ruiko.Or([ruiko.C('https:'),
                                 ruiko.C('http:')])),
            ruiko.Bind('slash', ruiko.C('//')),
            ruiko.Bind('head', ruiko.Seq(ruiko.N('pattern'), 1, -1)),
            ruiko.Bind(
                'tail',
                ruiko.Seq(
                    ruiko.And([ruiko.C('/'), ruiko.N('pattern')]), 0, -1)),
            ruiko.Seq(ruiko.C('/'), 0, 1)
        ])

    @staticmethod
    def rewrite(state):
        ctx = state.ctx
        prefix = ctx.get('prefix')
        slash = ctx.get('slash')
        head = ctx.get('head')
        tail = ctx.get('tail')

        def stream():
            (yield prefix)
            (yield slash)
            (yield from head)
            (yield from tail)

        return stream()


@ulang
class text(ruiko.Parser):
    @staticmethod
    def bnf():
        return ruiko.Seq(
            ruiko.Or([
                ruiko.Push('urls', ruiko.Named('url')),
                ruiko.AnyNot(ruiko.Named('url'))
            ]), 1, -1)

    @staticmethod
    def rewrite(state):
        ctx = state.ctx
        urls = ctx.get('urls')
        return tuple((recover_codes(each) for each in urls))


@ulang
class pattern(ruiko.Lexer):
    @staticmethod
    def regex():
        return ['[a-zA-Z0-9_]+']


@ulang
class space(ruiko.Lexer):
    @staticmethod
    def regex():
        return ['\\s+']


ulang.ignore()
ulang.build()
ulang.as_fixed()
_impl = ulang.implementation
from rbnf.core.State import State
_ze_exp = text.match
lexer = ulang.lexer
ze_exp = lambda text: _ze_exp(tuple(lexer(text)), State(_impl))