@feature(goto, staging)
def seq_match(tokenizers, state):
    root_history = state.commit()
    nested = Nested()
    now = 0
    _extend_fn = nested.extend
    _append_fn = nested.append
    label.0.block
    history = state.commit()
    sub_res = const.6(tokenizers, state)
    if (sub_res.status is const.12):
        state.reset(history)
        if (now >= const.8):
            jump.label_finish.jump
        jump.label_fail.jump
    elif (sub_res.status is const.13):
        stacked_func = sub_res.value
        jump.label_lr.jump
    sub_value = sub_res.value
    if (sub_value.__class__ is const.14):
        _extend_fn(sub_value)
    else:
        _append_fn(sub_value)
    now += 1
    jump.loop.jump
    label.1.block
    return const.15(const.16, nested)
    label.2.block
    if now:
        state.reset(root_history)
    return const.17
    label.3.block
    match__ = const.6
    (FINISH_, CONTINUE_, FAIL_) = (FINISH_, CONTINUE_, const.4)
    state_ = state

    def stacked_func_(ast: AST):

        def foreach(times: int, _extend_fn, _append_fn):
            if (times == most_):
                return FINISH_
            history = state_.commit()
            sub_res = match__(tokenizers, state_)
            if (sub_res.status is Unmatched):
                state_.reset(history)
                if (times >= least_):
                    return FINISH_
                return FAIL_
            elif (sub_res.status is FindLR):
                if (least_ is 0):
                    state_.reset(history)
                    warnings.warn(f"Left recursion supporting is ambiguous with repeatable parser({self}) that which couldn't fail.")
                    return FAIL_
                return sub_res.value
            sub_value = sub_res.value
            if (sub_value.__class__ is Nested):
                _extend_fn(sub_value)
            else:
                _append_fn(sub_value)
            return CONTINUE_
        now_ = now
        parsed_ = nested.copy()
        res = stacked_func(ast)
        if (res.status is Unmatched):
            return (Result.mismatched if (now_ < least_) else Result.match(parsed_))
        now_ += 1
        while True:
            status_ = foreach(now_, parsed_.extend, parsed_.append)
            if (status_ is FINISH_):
                return Result.match(parsed_)
            elif (status_ is CONTINUE_):
                now_ += 1
                continue
            return Result.mismatched
    return const.18(stacked_func_)